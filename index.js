require("dotenv").config();

const express = require("express");
const { Telegraf, Markup } = require("telegraf");
const { Pool } = require("pg");

// ================= ENV CHECK =================

const requiredEnv = [
  "BOT_TOKEN",
  "DATABASE_URL",
  "CHANNEL_ID",
  "PUBLIC_BASE_URL"
];

for (const k of requiredEnv) {
  if (!process.env[k]) {
    console.error(`Missing env: ${k}`);
    process.exit(1);
  }
}

// ================= INIT =================

const app = express();
app.use(express.json());

const bot = new Telegraf(process.env.BOT_TOKEN);

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

const PORT = process.env.PORT || 8080;
const WEBHOOK_PATH = `/telegraf/${process.env.BOT_TOKEN}`;
const WEBHOOK_URL = `${process.env.PUBLIC_BASE_URL}${WEBHOOK_PATH}`;

// ================= STATE MACHINE =================

const userState = {};

const STATES = {
  IDLE: "IDLE",
  CREATE_LOCATION: "CREATE_LOCATION",
  CREATE_DATE: "CREATE_DATE",
  CREATE_TIME: "CREATE_TIME",
  CREATE_ORG2: "CREATE_ORG2",
  JOIN_SECOND_PLAYER: "JOIN_SECOND_PLAYER"
};

// ================= DB INIT =================

async function initDB() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS games (
      id SERIAL PRIMARY KEY,
      location TEXT NOT NULL,
      date TEXT NOT NULL,
      time TEXT NOT NULL,
      organizer1 TEXT NOT NULL,
      organizer2 TEXT NOT NULL,
      pairs TEXT[] NOT NULL,
      is_closed BOOLEAN DEFAULT false
    );
  `);
}

// ================= START =================

bot.start(async (ctx) => {
  userState[ctx.from.id] = { state: STATES.IDLE };

  await ctx.reply(
    "üè∏ Badm Match Maker\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
    Markup.inlineKeyboard([
      [Markup.button.callback("–°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É", "create_game")],
      [Markup.button.callback("–°–ø–∏—Å–æ–∫ –∏–≥—Ä", "list_games")]
    ])
  );
});

// ================= CREATE FLOW =================

bot.action("create_game", async (ctx) => {
  await ctx.answerCbQuery();

  userState[ctx.from.id] = {
    state: STATES.CREATE_LOCATION,
    data: {}
  };

  await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é:");
});

// ================= LIST GAMES =================

bot.action("list_games", async (ctx) => {
  await ctx.answerCbQuery();

  const { rows } = await pool.query(
    "SELECT * FROM games WHERE is_closed=false ORDER BY id DESC"
  );

  if (!rows.length) {
    return ctx.reply("–ê–∫—Ç–∏–≤–Ω—ã—Ö –∏–≥—Ä –Ω–µ—Ç.");
  }

  for (const game of rows) {
    await ctx.reply(
      formatGame(game),
      Markup.inlineKeyboard([
        [Markup.button.callback("–ó–∞–ø–∏—Å–∞—Ç—å—Å—è –ø–∞—Ä–æ–π", `join_${game.id}`)]
      ])
    );
  }
});

// ================= JOIN =================

bot.action(/join_(\d+)/, async (ctx) => {
  await ctx.answerCbQuery();

  const gameId = ctx.match[1];

  const { rows } = await pool.query(
    "SELECT * FROM games WHERE id=$1",
    [gameId]
  );

  if (!rows.length) return;

  const game = rows[0];

  if (game.is_closed) {
    return ctx.reply("‚õî –ó–∞–ø–∏—Å—å –∑–∞–∫—Ä—ã—Ç–∞.");
  }

  if (game.pairs.length >= 3) {
    return ctx.reply("–ò–≥—Ä–∞ —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞.");
  }

  userState[ctx.from.id] = {
    state: STATES.JOIN_SECOND_PLAYER,
    gameId
  };

  await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞:");
});

// ================= TEXT HANDLER =================

bot.on("text", async (ctx) => {
  const stateObj = userState[ctx.from.id];
  if (!stateObj) return;

  const text = ctx.message.text;

  // ---- CREATE ----

  if (stateObj.state === STATES.CREATE_LOCATION) {
    stateObj.data.location = text;
    stateObj.state = STATES.CREATE_DATE;
    return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É (–Ω–∞–ø—Ä–∏–º–µ—Ä 25.02.2026):");
  }

  if (stateObj.state === STATES.CREATE_DATE) {
    stateObj.data.date = text;
    stateObj.state = STATES.CREATE_TIME;
    return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä 19:00):");
  }

  if (stateObj.state === STATES.CREATE_TIME) {
    stateObj.data.time = text;
    stateObj.state = STATES.CREATE_ORG2;
    return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é –≤—Ç–æ—Ä–æ–≥–æ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞:");
  }

  if (stateObj.state === STATES.CREATE_ORG2) {
    const organizer1 = `${ctx.from.first_name || ""} ${ctx.from.last_name || ""}`.trim();
    const organizer2 = text;

    const result = await pool.query(
      `INSERT INTO games 
       (location, date, time, organizer1, organizer2, pairs)
       VALUES ($1,$2,$3,$4,$5,$6)
       RETURNING id`,
      [
        stateObj.data.location,
        stateObj.data.date,
        stateObj.data.time,
        organizer1,
        organizer2,
        [`${organizer1} / ${organizer2}`]
      ]
    );

    const gameId = result.rows[0].id;

    delete userState[ctx.from.id];

    await publishGame(gameId);

    return ctx.reply("–ò–≥—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ ‚úÖ");
  }

  // ---- JOIN ----

  if (stateObj.state === STATES.JOIN_SECOND_PLAYER) {
    const firstPlayer = `${ctx.from.first_name || ""} ${ctx.from.last_name || ""}`.trim();
    const secondPlayer = text;
    const pair = `${firstPlayer} / ${secondPlayer}`;
    const gameId = stateObj.gameId;

    await pool.query(
      "UPDATE games SET pairs = array_append(pairs,$1) WHERE id=$2",
      [pair, gameId]
    );

    const { rows } = await pool.query(
      "SELECT pairs FROM games WHERE id=$1",
      [gameId]
    );

    if (rows[0].pairs.length >= 3) {
      await pool.query(
        "UPDATE games SET is_closed=true WHERE id=$1",
        [gameId]
      );
    }

    delete userState[ctx.from.id];

    await publishGame(gameId);

    return ctx.reply("–í—ã –∑–∞–ø–∏—Å–∞–Ω—ã ‚úÖ");
  }
});

// ================= FORMAT =================

function formatGame(game) {
  const list = [...game.pairs];
  while (list.length < 3) list.push("‚Äî");

  return `üè∏ ${game.location}
üìÖ ${game.date}
üïí ${game.time}

üë§ –û—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—ã:
${game.organizer1} / ${game.organizer2}

üéØ –§–æ—Ä–º–∞—Ç –¥–æ–ø—É—Å–∫–∞:
‚Ä¢ –ú–∞—Å—Ç–µ—Ä + –õ—é–±–∏—Ç–µ–ª—å
‚Ä¢ –î–≤–∞ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –ª—é–±–∏—Ç–µ–ª—è

üë• –ü–∞—Ä—ã:
1Ô∏è‚É£ ${list[0]}
2Ô∏è‚É£ ${list[1]}
3Ô∏è‚É£ ${list[2]}`;
}

// ================= PUBLISH =================

async function publishGame(gameId) {
  const { rows } = await pool.query(
    "SELECT * FROM games WHERE id=$1",
    [gameId]
  );

  const game = rows[0];

  await bot.telegram.sendMessage(
    process.env.CHANNEL_ID,
    formatGame(game),
    {
      reply_markup: {
        inline_keyboard: [
          [{ text: "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è –ø–∞—Ä–æ–π", callback_data: `join_${game.id}` }]
        ]
      }
    }
  );
}

// ================= SERVER =================

app.use(bot.webhookCallback(WEBHOOK_PATH));

(async () => {
  await initDB();
  await bot.telegram.setWebhook(WEBHOOK_URL);
  app.listen(PORT, () => {
    console.log("SERVER STARTED");
  });
})();
