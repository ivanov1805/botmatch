require("dotenv").config();

const express = require("express");
const { Telegraf, Markup } = require("telegraf");
const { Pool } = require("pg");

// ============ ENV CHECK ============
const requiredEnv = [
  "BOT_TOKEN",
  "DATABASE_URL",
  "CHANNEL_ID",
  "PUBLIC_BASE_URL"
];for (const k of requiredEnv) {
  if (!process.env[k]) {
    console.error(`Missing env: ${k}`);
    process.exit(1);
  }
}

const app = express();
app.use(express.json());

const bot = new Telegraf(process.env.BOT_TOKEN);

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

const CHANNEL_ID = process.env.CHANNEL_ID; // e.g. -1001234567890
const PUBLIC_BASE_URL = process.env.PUBLIC_BASE_URL.replace(/\/+$/, ""); // https://xxxx.up.railway.app

// ============ STATE MACHINE ============
const State = Object.freeze({
  IDLE: "IDLE",

  CREATE_WAIT_LOCATION: "CREATE_WAIT_LOCATION",
  CREATE_WAIT_DATE: "CREATE_WAIT_DATE",
  CREATE_WAIT_TIME: "CREATE_WAIT_TIME",
  CREATE_WAIT_ORG2_NAME: "CREATE_WAIT_ORG2_NAME",

  JOIN_WAIT_SECOND_PLAYER: "JOIN_WAIT_SECOND_PLAYER",
});

const sessions = new Map(); // key: telegram userId -> { state, data }

function getSession(userId) {
  if (!sessions.has(userId)) {
    sessions.set(userId, { state: State.IDLE, data: {} });
  }
  return sessions.get(userId);
}

function resetSession(userId) {
  sessions.set(userId, { state: State.IDLE, data: {} });
}

// ============ DB INIT ============
async function ensureSchema() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS games (
      id SERIAL PRIMARY KEY,
      location TEXT NOT NULL,
      date TEXT NOT NULL,
      time TEXT NOT NULL,

      organizer1_name TEXT NOT NULL,
      organizer1_user_id BIGINT NOT NULL,
      organizer1_username TEXT,

      organizer2_name TEXT NOT NULL,

      pairs TEXT[] NOT NULL DEFAULT '{}',
      is_closed BOOLEAN NOT NULL DEFAULT false,

      channel_message_id BIGINT
    );
  `);
}

// ============ HELPERS ============
function safeFullName(ctx) {
  const fn = (ctx.from.first_name || "").trim();
  const ln = (ctx.from.last_name || "").trim();
  return `${fn}${ln ? " " + ln : ""}`.trim();
}

function escapeText(s) {
  return String(s ?? "").replace(/\s+/g, " ").trim();
}

function organizerContactUrl(userId, username) {
  const u = (username || "").replace(/^@/, "").trim();
  if (u) return `https://t.me/${u}`;
  // Telegram deep link for opening chat with user by id (works in clients)
  return `tg://user?id=${userId}`;
}

function formatGameText(game) {
  const pairs = Array.isArray(game.pairs) ? [...game.pairs] : [];
  while (pairs.length < 3) pairs.push("â€”");

  return `ðŸ¸ ${game.location}
ðŸ“… ${game.date}
ðŸ•’ ${game.time}

ðŸ‘¤ ÐžÑ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ñ‹:
${game.organizer1_name} / ${game.organizer2_name}

ðŸŽ¯ Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð´Ð¾Ð¿ÑƒÑÐºÐ°:
â€¢ ÐœÐ°ÑÑ‚ÐµÑ€ + Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ
â€¢ Ð”Ð²Ð° Ð¿Ñ€Ð¾Ð´Ð²Ð¸Ð½ÑƒÑ‚Ñ‹Ñ… Ð»ÑŽÐ±Ð¸Ñ‚ÐµÐ»Ñ

ðŸ‘¥ ÐŸÐ°Ñ€Ñ‹:
1ï¸âƒ£ ${pairs[0]}
2ï¸âƒ£ ${pairs[1]}
3ï¸âƒ£ ${pairs[2]}

â„¹ï¸ Ð’Ñ‹Ð¿Ð¸ÑÐ°Ñ‚ÑŒÑÑ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð°Ð¿Ð¸ÑÐ°Ð² Ð¾Ñ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ñƒ.`;
}

function gameKeyboard(game) {
  return Markup.inlineKeyboard([
    [Markup.button.callback("âœ… Ð—Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒÑÑ Ð¿Ð°Ñ€Ð¾Ð¹", `join:${game.id}`)],
    [
      Markup.button.url(
        "âœ‰ï¸ ÐÐ°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð¾Ñ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ñƒ",
        organizerContactUrl(game.organizer1_user_id, game.organizer1_username)
      ),
    ],
  ]);
}

async function loadGame(gameId) {
  const { rows } = await pool.query("SELECT * FROM games WHERE id=$1", [gameId]);
  return rows[0] || null;
}

async function publishGame(gameId) {
  const game = await loadGame(gameId);
  if (!game) return;

  const text = formatGameText(game);
  const keyboard = gameKeyboard(game);

  // If already posted to channel - edit, else send and save message_id
  if (game.channel_message_id) {
    try {
      await bot.telegram.editMessageText(
        CHANNEL_ID,
        Number(game.channel_message_id),
        undefined,
        text,
        keyboard
      );
      return;
    } catch (e) {
      // Message could be deleted or edit not allowed - fallback to send new
      console.error("editMessageText failed, fallback to send:", e?.message || e);
    }
  }

  const sent = await bot.telegram.sendMessage(CHANNEL_ID, text, keyboard);
  await pool.query("UPDATE games SET channel_message_id=$1 WHERE id=$2", [
    sent.message_id,
    gameId,
  ]);
}

// ============ BOT UI ============
async function sendMainMenu(ctx) {
  return ctx.reply(
    "ðŸ¸ Badm Match Maker\n\nÐ’Ñ‹Ð±ÐµÑ€Ð¸ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ:",
    Markup.inlineKeyboard([
      [Markup.button.callback("âž• Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¸Ð³Ñ€Ñƒ", "create")],
      [Markup.button.callback("ðŸ“‹ Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¸Ð³Ñ€", "list")],
    ])
  );
}

bot.start(async (ctx) => {
  resetSession(ctx.from.id);
  await sendMainMenu(ctx);
});

bot.action("create", async (ctx) => {
  await ctx.answerCbQuery();
  const s = getSession(ctx.from.id);
  s.state = State.CREATE_WAIT_LOCATION;
  s.data = {};
  await ctx.reply("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð»Ð¾ÐºÐ°Ñ†Ð¸ÑŽ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€: Ð›ÑƒÐ¶Ð½Ð¸ÐºÐ¸):");
});

bot.action("list", async (ctx) => {
  await ctx.answerCbQuery();

  const { rows } = await pool.query("SELECT * FROM games WHERE is_closed=false ORDER BY id DESC LIMIT 20");
  if (!rows.length) return ctx.reply("ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… Ð¸Ð³Ñ€ Ð½ÐµÑ‚.");

  for (const g of rows) {
    await ctx.reply(formatGameText(g), gameKeyboard(g));
  }
});

bot.action(/^join:(\d+)$/, async (ctx) => {
  await ctx.answerCbQuery();
  const gameId = Number(ctx.match[1]);

  const game = await loadGame(gameId);
  if (!game) return ctx.reply("Ð˜Ð³Ñ€Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°.");

  if (game.is_closed) return ctx.reply("â›” Ð—Ð°Ð¿Ð¸ÑÑŒ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.");
  const pairs = Array.isArray(game.pairs) ? game.pairs : [];
  if (pairs.length >= 3) return ctx.reply("â›” Ð£Ð¶Ðµ 3 Ð¿Ð°Ñ€Ñ‹. Ð—Ð°Ð¿Ð¸ÑÑŒ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.");

  const s = getSession(ctx.from.id);
  s.state = State.JOIN_WAIT_SECOND_PLAYER;
  s.data = { joinGameId: gameId };

  await ctx.reply("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸ÑŽ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð¸Ð³Ñ€Ð¾ÐºÐ° Ð²Ð°ÑˆÐµÐ¹ Ð¿Ð°Ñ€Ñ‹:");
});

// ============ SINGLE TEXT HANDLER (NO DUPLICATES) ============
bot.on("text", async (ctx) => {
  const userId = ctx.from.id;
  const text = escapeText(ctx.message.text);
  const s = getSession(userId);

  // allow reset command
  if (text === "/cancel" || text === "Ð¾Ñ‚Ð¼ÐµÐ½Ð°") {
    resetSession(userId);
    return ctx.reply("ÐžÐº, Ð¾Ñ‚Ð¼ÐµÐ½Ð¸Ð». /start Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ð°Ñ‡Ð°Ñ‚ÑŒ Ð·Ð°Ð½Ð¾Ð²Ð¾.");
  }

  switch (s.state) {
    case State.CREATE_WAIT_LOCATION: {
      if (!text) return ctx.reply("Ð›Ð¾ÐºÐ°Ñ†Ð¸Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ð¾Ð¹. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·:");
      s.data.location = text;
      s.state = State.CREATE_WAIT_DATE;
      return ctx.reply("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´Ð°Ñ‚Ñƒ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ 25.02.2026):");
    }

    case State.CREATE_WAIT_DATE: {
      if (!text) return ctx.reply("Ð”Ð°Ñ‚Ð° Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ð¾Ð¹. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·:");
      s.data.date = text;
      s.state = State.CREATE_WAIT_TIME;
      return ctx.reply("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ñ€ÐµÐ¼Ñ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ 19:00):");
    }

    case State.CREATE_WAIT_TIME: {
      if (!text) return ctx.reply("Ð’Ñ€ÐµÐ¼Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·:");
      s.data.time = text;
      s.state = State.CREATE_WAIT_ORG2_NAME;
      return ctx.reply("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸ÑŽ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð¾Ñ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ð° (Ð²Ð°Ñˆ Ð¿Ð°Ñ€Ñ‚Ð½Ñ‘Ñ€):");
    }

    case State.CREATE_WAIT_ORG2_NAME: {
      if (!text) return ctx.reply("Ð˜Ð¼Ñ/Ñ„Ð°Ð¼Ð¸Ð»Ð¸Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼Ð¸. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·:");
      s.data.organizer2 = text;

      const organizer1Name = safeFullName(ctx) || "ÐžÑ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€";
      const organizer2Name = s.data.organizer2;

      // organizer pair is always pre-filled (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ)
      const pair = `${organizer1Name} / ${organizer2Name}`;

      const { rows } = await pool.query(
        `INSERT INTO games
          (location, date, time, organizer1_name, organizer1_user_id, organizer1_username, organizer2_name, pairs, is_closed)
         VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
         RETURNING id`,
        [
          s.data.location,
          s.data.date,
          s.data.time,
          organizer1Name,
          Number(ctx.from.id),
          ctx.from.username || null,
          organizer2Name,
          [pair],
          false,
        ]
      );

      const gameId = rows[0].id;

      resetSession(userId);

      await publishGame(gameId);
      await ctx.reply("Ð˜Ð³Ñ€Ð° ÑÐ¾Ð·Ð´Ð°Ð½Ð° âœ…\nÐŸÐ¾ÑÑ‚ Ð¾Ð¿ÑƒÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°Ð½ Ð² ÐºÐ°Ð½Ð°Ð»Ðµ.");

      return sendMainMenu(ctx);
    }

    case State.JOIN_WAIT_SECOND_PLAYER: {
      const gameId = s.data.joinGameId;
      if (!gameId) {
        resetSession(userId);
        return ctx.reply("Ð¡ÐµÑÑÐ¸Ñ ÑÐ»Ð¾Ð¼Ð°Ð»Ð°ÑÑŒ. /start");
      }
      if (!text) return ctx.reply("Ð˜Ð¼Ñ/Ñ„Ð°Ð¼Ð¸Ð»Ð¸Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼Ð¸. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·:");

      const game = await loadGame(gameId);
      if (!game) {
        resetSession(userId);
        return ctx.reply("Ð˜Ð³Ñ€Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°. /start");
      }
      if (game.is_closed) {
        resetSession(userId);
        return ctx.reply("â›” Ð—Ð°Ð¿Ð¸ÑÑŒ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.");
      }

      // re-check capacity
      const pairs = Array.isArray(game.pairs) ? [...game.pairs] : [];
      if (pairs.length >= 3) {
        resetSession(userId);
        return ctx.reply("â›” Ð£Ð¶Ðµ 3 Ð¿Ð°Ñ€Ñ‹. Ð—Ð°Ð¿Ð¸ÑÑŒ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.");
      }

      const firstPlayer = safeFullName(ctx) || "Ð˜Ð³Ñ€Ð¾Ðº";
      const secondPlayer = text;
      const pair = `${firstPlayer} / ${secondPlayer}`;

      // prevent duplicate same pair string (simple guard)
      if (pairs.includes(pair)) {
        resetSession(userId);
        return ctx.reply("Ð­Ñ‚Ð° Ð¿Ð°Ñ€Ð° ÑƒÐ¶Ðµ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ð°.");
      }

      // update atomically
      await pool.query(
        `UPDATE games
         SET pairs = array_append(pairs, $1)
         WHERE id = $2`,
        [pair, gameId]
      );

      const updated = await loadGame(gameId);
      const updatedPairs = Array.isArray(updated.pairs) ? updated.pairs : [];

      if (updatedPairs.length >= 3) {
        await pool.query("UPDATE games SET is_closed=true WHERE id=$1", [gameId]);
      }

      resetSession(userId);

      await publishGame(gameId);
      await ctx.reply("Ð—Ð°Ð¿Ð¸ÑÐ°Ð» âœ…\nÐ•ÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾ Ð²Ñ‹Ð¿Ð¸ÑÐ°Ñ‚ÑŒÑÑ â€” Ð½Ð°Ð¿Ð¸ÑˆÐ¸ Ð¾Ñ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ñƒ.");

      return sendMainMenu(ctx);
    }

    case State.IDLE:
    default:
      return ctx.reply("Ð¯ Ñ‚ÐµÐ±Ñ Ð¿Ð¾Ð½ÑÐ», Ð½Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ Ð½ÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ.\nÐÐ°Ð¶Ð¼Ð¸ /start");
  }
});

// ============ WEBHOOK + EXPRESS ============
app.get("/", (_req, res) => res.status(200).send("OK"));

app.use(bot.webhookCallback("/telegraf"));

async function main() {
  await ensureSchema();

  const port = process.env.PORT || 8080;
  app.listen(port, async () => {
    console.log(`SERVER STARTED ON PORT ${port}`);

    const webhookUrl = `${PUBLIC_BASE_URL}/telegraf`;
    await bot.telegram.setWebhook(webhookUrl);
    console.log("WEBHOOK SET", webhookUrl);
  });
}

main().catch((e) => {
  console.error("FATAL:", e);
  process.exit(1);
});
