require("dotenv").config();
const { Telegraf, Markup } = require("telegraf");
const sqlite3 = require("sqlite3").verbose();

const bot = new Telegraf(process.env.BOT_TOKEN);
const db = new sqlite3.Database("./database.sqlite");

db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS games (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    location TEXT,
    date TEXT,
    time TEXT,
    format TEXT,
    totalCost INTEGER,
    pairs TEXT DEFAULT '',
    status TEXT DEFAULT 'OPEN',
    messageId INTEGER
  )`);
});

function formatKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback("–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ª—é–±–∏—Ç–µ–ª–∏", "FMT_ADV")],
    [Markup.button.callback("–ú–∞—Å—Ç–µ—Ä+–õ—é–±–∏—Ç–µ–ª—å", "FMT_ML")]
  ]);
}

function levelKeyboard(gameId) {
  return Markup.inlineKeyboard([
    [{ text: "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ª—é–±–∏—Ç–µ–ª–∏", callback_data: `LVL_A_${gameId}` }],
    [{ text: "–ú–∞—Å—Ç–µ—Ä+–õ—é–±–∏—Ç–µ–ª—å", callback_data: `LVL_ML_${gameId}` }]
  ]);
}

function renderGame(game) {
  const pairs = game.pairs ? JSON.parse(game.pairs) : [];
  const pairCount = pairs.length;
  const pricePerPair = Math.ceil(game.totalCost / 3);

  let text = `
üè∏ –û–¢–ö–†–´–¢–ê–Ø –ò–ì–†–ê

üìç ${game.location}
üóì ${game.date}
‚è∞ ${game.time}

üéØ –§–æ—Ä–º–∞—Ç: ${game.format}
üë• –ü–∞—Ä—ã: ${pairCount}/3

`;

  pairs.forEach((p, i) => {
    text += `${i + 1}. ${p.player1} + ${p.player2} (${p.level})\n`;
  });

  text += `
üí∞ –ö–æ—Ä—Ç: ${game.totalCost} ‚ÇΩ
üí≥ –° –ø–∞—Ä—ã: ${pricePerPair} ‚ÇΩ
`;

  if (pairCount >= 2) text += `\n‚úÖ –ò–ì–†–ê –°–û–ë–†–ê–ù–ê`;
  if (pairCount === 3) text += `\nüîí –ü–û–õ–ù–ê–Ø`;

  return text;
}

let createState = {};
let joinState = {};

bot.start((ctx) => {
  ctx.reply("–ö–æ–º–∞–Ω–¥–∞ /newgame ‚Äî —Å–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É");
});

bot.command("newgame", (ctx) => {
  createState[ctx.from.id] = { step: "location" };
  ctx.reply("–í–≤–µ–¥–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é");
});

bot.on("text", (ctx) => {
  const state = createState[ctx.from.id];
  return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –§–∞–º–∏–ª–∏—é –∏ –ò–º—è –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞\n–ü—Ä–∏–º–µ—Ä: –ü–µ—Ç—Ä–æ–≤ –ê–Ω–¥—Ä–µ–π");

  if (state) {
    if (state.step === "location") {
      state.location = ctx.message.text.trim();
      state.step = "date";
      return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É");
    }

    if (state.step === "date") {
      state.date = ctx.message.text.trim();
      state.step = "time";
      return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è");
    }

    if (state.step === "time") {
      state.time = ctx.message.text.trim();
      state.step = "format";
      return ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç", formatKeyboard());
    }

    if (state.step === "cost") {
      const cost = parseInt(ctx.message.text, 10);
      if (!cost) return ctx.reply("–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å —á–∏—Å–ª–æ–º");

      state.totalCost = cost;

      db.run(
        `INSERT INTO games (location,date,time,format,totalCost) VALUES (?,?,?,?,?)`,
        [state.location, state.date, state.time, state.format, state.totalCost],
        function () {
          db.get(`SELECT * FROM games WHERE id=?`, [this.lastID], (err, game) => {
            if (!game) return;

            bot.telegram
              .sendMessage(process.env.CHANNEL_ID, renderGame(game), {
                reply_markup: {
                  inline_keyboard: [
                    [{ text: "–ó–∞–ø–∏—Å–∞—Ç—å –ø–∞—Ä—É", callback_data: `JOIN_${game.id}` }]
                  ]
                }
              })
              .then((msg) => {
                db.run(`UPDATE games SET messageId=? WHERE id=?`,
                  [msg.message_id, game.id]);
              });
          });
        }
      );

      delete createState[ctx.from.id];
      return ctx.reply("–ò–≥—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞");
    }

    if (state.step === "format") {
      return ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∫–Ω–æ–ø–∫–æ–π", formatKeyboard());
    }
  }

if (join) {
  if (!join.player1) {
    const t = ctx.message.text.trim();
    if (!t.includes(" "))
      return ctx.reply("–ù—É–∂–Ω–æ –§–∞–º–∏–ª–∏—è –∏ –ò–º—è —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª. –ü—Ä–∏–º–µ—Ä: –ò–≤–∞–Ω–æ–≤ –°–µ—Ä–≥–µ–π");

    join.player1 = t;
    return ctx.reply("–í–≤–µ–¥–∏—Ç–µ –§–∞–º–∏–ª–∏—é –∏ –ò–º—è –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞\n–ü—Ä–∏–º–µ—Ä: –ü–µ—Ç—Ä–æ–≤ –ê–Ω–¥—Ä–µ–π");
  }

  if (!join.player2) {
    const t = ctx.message.text.trim();
    if (!t.includes(" "))
      return ctx.reply("–ù—É–∂–Ω–æ –§–∞–º–∏–ª–∏—è –∏ –ò–º—è —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª. –ü—Ä–∏–º–µ—Ä: –ü–µ—Ç—Ä–æ–≤ –ê–Ω–¥—Ä–µ–π");

    join.player2 = t;
    return ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å –ø–∞—Ä—ã", levelKeyboard(join.gameId));
  }
}

bot.action(/^FMT_(ADV|ML)$/, async (ctx) => {
  console.log("FORMAT CLICK:", ctx.callbackQuery.data);

  const state = createState[ctx.from.id];
  if (!state) return ctx.answerCbQuery("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");

  const levelCode = ctx.match[1];

  if (levelCode === "ADV")
    state.format = "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ª—é–±–∏—Ç–µ–ª–∏";

  if (levelCode === "ML")
    state.format = "–ú–∞—Å—Ç–µ—Ä+–õ—é–±–∏—Ç–µ–ª—å";

  state.step = "cost";

  await ctx.answerCbQuery("OK");
  ctx.reply("–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –∫–æ—Ä—Ç–∞");
});bot.action(/FMT_/, async (ctx) => {
  console.log("FORMAT CLICK:", ctx.callbackQuery.data);

  const state = createState[ctx.from.id];
  if (!state) return ctx.answerCbQuery("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");

  if (ctx.match[0] === "FMT_ADV")
    state.format = "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ª—é–±–∏—Ç–µ–ª–∏";

  if (ctx.match[0] === "FMT_ML")
    state.format = "–ú–∞—Å—Ç–µ—Ä+–õ—é–±–∏—Ç–µ–ª—å";

  state.step = "cost";

  await ctx.answerCbQuery("OK");
  ctx.reply("–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –∫–æ—Ä—Ç–∞");
});

bot.action(/JOIN_/, (ctx) => {
  const gameId = ctx.match[0].split("_")[1];

  db.get(`SELECT * FROM games WHERE id=?`, [parseInt(gameId)], (err, game) => {
    if (!game) return ctx.answerCbQuery("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∞ –ù–û–í–û–ô –∫–∞—Ä—Ç–æ—á–∫–µ (—Å—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ –±–∞–∑—ã –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç).");

    const pairs = game.pairs ? JSON.parse(game.pairs) : [];
    if (pairs.length >= 3)
      return ctx.answerCbQuery("–ò–≥—Ä–∞ —É–∂–µ –ø–æ–ª–Ω–∞—è");

    joinState[ctx.from.id] = { gameId };
    ctx.reply("–í–≤–µ–¥–∏—Ç–µ –§–∞–º–∏–ª–∏—é –∏ –ò–º—è –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞\n–ü—Ä–∏–º–µ—Ä: –ò–≤–∞–Ω–æ–≤ –°–µ—Ä–≥–µ–π");
  });
});

bot.action(/LVL_/, (ctx) => {
  const [_, levelCode, gameId] = ctx.match[0].split("_");
  const join = joinState[ctx.from.id];
  if (!join) return;

  let level = levelCode === "A"
    ? "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ª—é–±–∏—Ç–µ–ª–∏"
    : "–ú–∞—Å—Ç–µ—Ä+–õ—é–±–∏—Ç–µ–ª—å";

  db.get(`SELECT * FROM games WHERE id=?`, [parseInt(gameId)], (err, game) => {
    if (!game) return;

    const pairs = game.pairs ? JSON.parse(game.pairs) : [];
    pairs.push({
      player1: join.player1,
      player2: join.player2,
      level
    });

    const status =
      pairs.length === 3 ? "FULL"
      : pairs.length >= 2 ? "READY"
      : "OPEN";

    db.run(
      `UPDATE games SET pairs=?, status=? WHERE id=?`,
      [JSON.stringify(pairs), status, parseInt(gameId)],
      () => {
        db.get(`SELECT * FROM games WHERE id=?`,
          [parseInt(gameId)],
          (err, updatedGame) => {

            bot.telegram.editMessageText(
              process.env.CHANNEL_ID,
              updatedGame.messageId,
              null,
              renderGame(updatedGame),
              {
                reply_markup:
                  status === "FULL"
                    ? {}
                    : {
                        inline_keyboard: [
                          [{ text: "–ó–∞–ø–∏—Å–∞—Ç—å –ø–∞—Ä—É", callback_data: `JOIN_${gameId}` }]
                        ]
                      }
              }
            );
          });
      });

    delete joinState[ctx.from.id];
    ctx.reply("–ü–∞—Ä–∞ –∑–∞–ø–∏—Å–∞–Ω–∞");
  });
});

bot.launch();
console.log("BOT LAUNCHED");
